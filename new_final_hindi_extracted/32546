रेग्युलर ऍक्सप्रैशन

नियमित व्यंजक या रेग्युलर ऍक्सप्रैशन कम्प्यूटिंग में स्ट्रिंग्स की खोज (find) या खोजो-और-बदलो (find and replace) के लिए संक्षिप्त, लचीला और सुविधाजनक तरीका है। उदाहरण के लिये कम[लर] खोजने पर यह कमल को भी खोजेगा और कमर को भी। रेग्युलर ऍक्सप्रैशन को regex या regexp के रूप में संक्षेपित किया जाता है। ye do prakar ke hote h.zero strings ko null strings bhi khte h

रेग्युलर ऍक्सप्रैशन का प्रयोग कई प्रोग्रामन भाषाओं में करना सम्भव है (जैसे जावास्क्रिप्ट में) इसके प्रयोग से एक ही लाइन में बहुत बड़ी बात कही या लिखी जा सकती है जिससे प्रोग्राम छोटा और सुवाच्य (वाचने में सरल) हो जाता है। जो प्रोग्रामर नहीं हैं उनके लिये यह 'फाइण्ड ऐण्ड रिप्लेस' के रूप में इसका बहुत उपयोग है।

निम्नलिखित उदाहरण कुछ ऐसी विशेषताओं को स्पष्ट करते हैं, जिन्हें रेग्युलर ऍक्सप्रैशन में अभिव्यक्त किया जा सके: 

रेग्युलर ऍक्सप्रैशन इन उदाहरणों से भी अधिक जटिल हो सकते हैं:
रेग्युलर ऍक्सप्रैशन के प्रयोग कई पाठ संपादकों द्वारा उपयोगिता एवं भाषाओँ की प्रोग्रामिंग में पैटर्न पर आधारित मूल पाठ की खोज और उसमें मनचाहे बदलाव के लिए किया गए हैं। उदाहरण के लिए, Perl, Ruby और Tcl सशक्त रेग्युलर ऍक्सप्रैशन इंजिन उनके वाक्य विन्यास में बना हुआ है। Unix वितरणों के द्वारा प्रदत्त अनेक उपयोगिताएं -- संपादक ed एवं फिल्टर grep—रेग्युलर ऍक्सप्रैशन की अवधारणा को लोकप्रिय बनाने में सर्वप्रथम थे।

वाक्य रचना के एक उदाहरण के रूप में, रेग्युलर ऍक्सप्रैशन codice_1 का प्रयोग "शब्द सीमाओं" (codice_2 द्वारा संकेतित) के बाद आने वाले ""ex" " स्ट्रिंग के सभी उदाहरणों की खोज के लिए हो सकता है। अल्पज्ञों की शब्दावली में, codice_1 अपने से मिलता जुलता स्ट्रिंग "ex" को दो संभावित क्षेत्रों में खोज लेगा, शब्दों के आरंभ में और एक स्ट्रिंग में दो वर्णों के बीच में, जिसमें से एक तो शब्द वर्ण है और दूसरा शब्द वर्ण नहीं है। इस प्रकार, स्ट्रिंग में "Texts for experts", codice_1 "एक्सपर्ट्स" में तो ""ex" " के साथ मेल खाता है, लेकिन "Texts" में मेल नहीं खाता (क्योंकि ""ex" " एक शब्द की सीमा में आ जाता है न कि शब्द सीमा के तुंरत बाद).

कई आधुनिक कम्प्यूटिंग प्रणालियां एक फाइल सिस्टम से फाइलनेम्स के साथ मेल खिलाने के लिए वाइल्डकार्ड वर्ण उपलब्ध कराती हैं। यह कई कमांड-लाइन शेल्स की आभ्यंतर क्षमता है, जिसे ग्लोबिंग के रूप में भी जाना जाता है। वाइल्डकार्ड आमतौर पर रेग्युलर ऍक्सप्रैशन से केवल विकल्पों को सीमित रूप में सूचित करने के मामले में भिन्न है।


रेग्युलर ऍक्सप्रैशन वाक्य विन्यास की उत्पत्ति में उपयोगी हैं जो प्रणालियों को उजागर करते हैं, जैसे कि डेटा सत्यापन और कई अन्य कार्यों के निष्पादन में.

रेग्युलर ऍक्सप्रैशन खोज इंजन के लिए उपयोगी होगा जैसे Google, Bing या Yahoo! Search में तो संपूर्ण डेटाबेस से होकर गुजरते हुए प्रोसेसिंग करना जटिलता और रिजेक्स की डिजाइन को देखते हुए अधिक कम्प्यूटर संसाधन खर्च करना होगा। हालांकि कई स्थितियों में सिस्टम प्रशासक रिजेक्स आधारित आंतरिक प्रश्नों को चला सकता है, अधिकतर सर्च इंजन लोगों को रिजेक्स की सहायता उपलब्ध नहीं कराते. एक उल्लेखनीय अपवाद गूगल कोड सर्च है।

रेग्युलर ऍक्सप्रैशन, जिसे प्रायः पैटर्न भी कहा जाता है, एक ऐसा सूचक है जो स्ट्रिंग्स के एक सेट के बारे में विस्तार से बतलाता है। उनका उपयोग आमतौर पर तत्वों की सूची बनाए बिना सेट के बारे में संक्षेप में बताने के लिए होता है। उदाहरण के लिए, 'सेट' जिसमें तीन स्ट्रिंग्स होते हैं ""Handel" ", ""Händel" " और ""Haendel" " को codice_5 codice_6 के पैटर्न के रूप में वर्णित किया जा सकता है (या वैकल्पिक रूप से, ऐसा कहा जाता है कि पैटर्न तीन में से प्रत्येक स्ट्रिंग के साथ "मेल" खाते हैं). अधिकतर आकारवादों (श्रृंखलाओं) में अगर कोई रिजेक्स किसी खास सेट के साथ मेल खाता है तो यह जान लेना चाहिए कि ऐसे सूचकों की अनंत संख्या है। अधिकांश आकारवाद निम्नलिखित क्रियाओं के लिए रेग्युलर ऍक्सप्रैशन बनाती हैं।




इन बनावटों को मनमाने ढंग से जटिल सूचकों के गठन के लिए एक साथ जोड़ दिया जा सकता है, ठीक उसी तरह जिस तरह कोई अंकगणितीय सूचकों का गठन संख्याओं एवं संक्रियाओं +, −, × और ÷ से कर सकता है। उदाहरण के लिए, codice_13codice_14 एवं codice_15 दोनों ही प्रामाणिक पैटर्न हैं, जो पिछले उदाहरण की ही तह समान स्ट्रिंग्स के साथ मेल खाता है, वह पिछला उदाहरण है codice_5codice_6.

रेग्युलर ऍक्सप्रैशन के लिए सटीक वाक्य-विन्यास उपकरणों और संदर्भ के साथ बदलते रहते हैं; अधिक विवरण "वाक्य-विन्यास" खंड में दिया गया है।

रेग्युलर ऍक्सप्रैशन की जड़ें ऑटोमेटा सिद्धांत एवं औपचारिक भाषा सिद्धांत में निहित हैं, दोनों ही सैद्धांतिक कंप्यूटर विज्ञान के अंग हैं। ये क्षेत्र प्रशिक्षण कंप्यूटेशन (ऑटोमेटा) एवं औपचारिक भाषाओं के वर्णन एवं वर्गीकरण की पद्धतियों के मॉडल हैं। 1950 के दशक में, गणितज्ञ स्टीफेन कोल क्लीन ने अपने गणितीय संकेतन का प्रयोग करते हुए इन मॉडलों का सविस्तार वर्णन किया, जिसे "रेगुलर सेट्स" कहते हैं। SNOBOL की भाषा पैटर्न मिलान कराने का आरंभिक उपकरण था, लेकिन रेग्युलर ऍक्सप्रैशन के सदृश नहीं. केन थॉम्पसन ने टेक्स्ट फाइल्स में पैटर्न्स के मिलान कराने के माध्यम के रूप में क्लीन के संकेतन का उपयोग संपादक QED के गठन में किया। बाद में उन्होंने Unix संपादक ed में इस क्षमता को जोड़ा, जिसने अंततः रेग्युलर ऍक्सप्रैशन के उपयोग के लिए लोकप्रिय खोजी उपकरण ग्रेप का पता लगाया ("grep" शब्द रेग्युलर ऍक्सप्रैशन ed संपादक की खोज के कमांड से लिया गया है codice_18 जिसमें "re" रेग्युलर ऍक्सप्रैशन का द्योतक है). समयांतराल से, रेग्युलर ऍक्सप्रैशन के थॉम्पसन के मौलिक रूपांतर में कई बदलाव आए हैं, जिनका व्यापक प्रयोग Unix और Unix जैसी ही प्रयोज्यता, expr, AWK, Emacs, vi और lex सहित हुआ है।

Perl और Tcl रेग्युलर ऍक्सप्रैशन हेनरी स्पेंसर लिखित रिजेक्स लाइब्रेरी से ली गई थीं, हालांकि Perl को स्पेंसर की लाइब्रेरी में अनेक नई विशेषताएं जोड़ने के लिए प्रसारित किया गया।फिलिप हेज़ेल ने PCRE (पर्ल कम्पैटिबल रेग्युलर ऍक्सप्रैशन) को विकसित किया, जो पर्ल की रेग्युलर ऍक्सप्रैशन की कार्यशीलता की लगभग नकल करने की कोशिश करता है, एवं अनेक आधुनिक उपकरणों PHP और Apache HTTP Server के द्वारा प्रयोग में लाया जाता है। Perl 6 की डिज़ाइन की प्रचेष्टा का एक हिस्सा पर्ल के रेग्युलर ऍक्सप्रैशन के एकीकरण में सुधार तथा उनके कार्यक्षेत्र एवं क्षमताओं को बढ़ाना ताकि सूचकों की पदव्याख्या के व्याकरण को परिभाषित करने का मौका दिया जा सके. परिणामस्वरूप एक लघु भाषा Perl 6 नियम बनी, जिसका प्रयोग Perl 6 ग्रामर को परिभाषित करने और साथ ही साथ भाषा में प्रोग्रामर्स के लिए उपकरण मुहैया कराने के लिया होता है। ये नियम पर्ल 5.x रेग्युलर ऍक्सप्रैशन की विशेषताओं को कायम रखते हैं, लेकिन उप-नियमों के द्वारा पुनःप्रवाही सुंदर पद व्याख्या की BNF-शैली की परिभाषा को भी अनुमति प्रदान करते हैं।

दस्तावेज़ और डाटाबेस मॉडलिंग के लिए संरचित सूचना मानकों में रेग्युलर ऍक्सप्रैशन का प्रयोग 1960 के दशक में आरंभ हुआ और 1980 के दशक में फैल गया, जब ISO SGML (ANSI "GCA 101-1983" द्वारा पूर्व आरोपित) उद्योग मानक समेकित हुए. भाषा मानकों में संरचना की सुस्पष्टता के केंद्र में रेग्युलर ऍक्सप्रैशन हैं। समूह वाक्य विन्यास में DTD तत्व का सरल उपयोग स्पष्ट है।

पैटर्न मिलान: इतिहास भी देखें

रेग्युलर ऍक्सप्रैशन को औपचारिक भाषा सिद्धांत के रूप में परिभाषित किया जा सकता है। रेग्युलर ऍक्सप्रैशन में स्थिरांक और ऑपरेटर्स होते हैं, जो स्ट्रिंग्स के सेट्स इन सेटों पर क्रियाशीलताओं को क्रमशः सूचित करते हैं। निम्नलिखित परिभाषा मानक है और औपचारिक भाषा सिद्धांत की अधिकांश पाठ्य पुस्तकों में पायी जाती है. एक सीमाबद्ध वर्णमाला Σ को देखते हुए निम्नलिखित स्थिरांकों की परिभाषा दी गई है:


निम्नलिखित संक्रियाएं परिभाषित हैं: 
| α in "R" and β in "S" } को संकेतित करता है। उदाहरण के लिए {"ab", "c"}{"d", "ef"} = {"abd", "abef", "cd", "cef"}.

| "S" जो "R" और "S" के गठबंधन को संकेतित करता है। उदाहरण के लिए {"ab", "c"}|{"ab", "d", "ef"} = {"ab", "c", "d", "ef"}.


कोष्ठकों से बचने के लिए यह मान लिया गया है कि क्लीन तारा को ही सर्वोच्च प्राथमिकता प्राप्त है और इसके बाद संयोजन और तब जाकर सेट गठबंधन को. अगर कोई संशय नहीं है तो कोष्ठकों का लोप हो सकता है। उदाहरण के लिए, codice_19 को codice_20 और codice_21 को codice_22 जैसा भी लिखा जा सकता है। 
कई पाठ्य पुस्तकों में लंबरूप बार के बदले संयोजन के लिए , , या चिह्नों का प्रयोग मिलता है।

उदाहरण: 
|b* {ε, {0}a, "b", "bb", "bbb", ...} को संकेतित करता है।

|b)* खाली स्ट्रिंग: {ε, {0}a, "b, "aa", "ab", "ba", "bb", "aaa", ...} समेत "a" और "b" " के अलावा बिना प्रतीक चिह्नों के सभी स्ट्रिंग के सेट को संकेतित करता है।

|ε) "a" से आरंभ कर स्ट्रिंग्स के सेट को, तब जीरो अथवा अधिक "b" s और अंत में विकल्प के साथ a "c" : 
