ऍसक्यूऍल

SQL (स्ट्रक्चर्ड क्वेरी लैंग्वेज़) [संरचित क्वेरी भाषा] () एक डेटाबेस प्रोग्रामिंग भाषा है जिसे "रिलेशनल डेटाबेस मैनेजमेंट सिस्टम्स" या संबंधपरक डेटाबेस प्रबंधन प्रणाली ("RDBMS") में आंकणों के प्रबंधन के लिए बनाया गया है और यह मूलतः "रिलेशनल ऐलजेब्रा" या संबंधपरक बीजगणित पर आधारित है। इसके दायरे में आंकणों पर प्रश्न (क्वेरी), आँकणों का अद्दतन (अपडेट), स्कीमा (प्रयोगकर्ता) निर्माण और रूपांतरण और "डेटा ऐक्सेस कंट्रोल" (आँकणों के उपयोग पर नियंत्रण) शामिल है। SQL, एडगर एफ. कॉड के रिलेशनल मॉडल के सबसे प्रारंभिक कम्प्यूटर प्रोग्रामिंग भाषाओं में से एक था जिसे उन्होंने अपने 1970 के प्रभावशाली दस्तावेज़ (पेपर), "ए रिलेशनल मॉडल ऑफ डेटा फॉर लार्ज शेयर्ड डेटा बैंक्स" में प्रस्तुत किया था और यह रिलेशनल डेटाबेसों के लिए सबसे व्यापक रूप से प्रयुक्त होने वाली भाषा बन गयी।

SQL को 1970 के दशक के शुरूआत में डैनियल रिचर्डसन, डॉनल्ड डी॰ चेम्बरलिन और रेमंड एफ. बॉयस द्वारा आइ०बी०ऍम० में विकसित किया गया था। यह संस्करण, जिसका प्रारंभिक नाम SEQUEL (सिक्वेल) था, आईबीएम के मूल रिलेशनल डेटाबेस उत्पाद सिस्टम आर. (System R) में संग्रहित डेटा के फेर-बदल तथा पुनःप्रतिष्ठापन के लिए डिजाइन किया गया था। IBM ने SQL के इस संस्करण का 1985 में पेटेंट करा लिया।

1970 के दशक के दौरान, IBM सैन जोस रिसर्च लैबॉरेटरी में एक समूह ने सिस्टम रिलेशनल डेटाबेस मैनेजमेंट सिस्टम को विकसित किया। उसके बाद IBM के डॉनल्ड डी. चैंबर्लिन और रेमंड एफ. बॉयस ने सिस्टम आर. (System R) में संग्रहित डेटा के प्रबंधन के लिए स्ट्रक्चर्ड इंग्लिश क्वेरी लैंग्वेज़ (SEQUEL या SEQL) की रचना की। आदिवर्णिक शब्द SEQUEL को बाद में बदल कर SQL कर दिया गया क्योंकि "SEQUEL" UK स्थित हॉकर सिडली नामक विमान कंपनी का ट्रेडमार्क था।

1970 के दशक के आरंभ में MIT में विकसित RDMS और 1974 में यू.सी. बर्कले (U.C. Berkely) में विकसित इन्ग्रेस (Ingres), पहले "रिलेशनल डेटाबेस मैनेजमेंट सिस्टम (RDBMS)" थे। इन्ग्रेस (Ingres) ने QUEL नामक एक क्वेरी लैंग्वेज़ को कार्यान्वित किया जिसे बाद में बाज़ार में SQL ने विस्थापित कर दिया। 

1970 के दशक के आखिर में, रिलेशनल सॉफ्टवेयर, इंक. [Relational Software, Inc.] (अब ओरेकल कॉर्पोरेशन) ने कॉड, चैंबर्लिन और बॉयस द्वारा उल्लेखित अवधारणाओं की संभाव्यता को देखा और स्वयं की SQL आधारित RDBMS को इस आकांक्षा के साथ विकसित किया कि वह उसे यू.एस. नेवी, सेन्ट्रल इंटेलिजेंस एजेंसी और यू.एस. गवर्नमेंट एजेंसियों को बेच सके। 1979 की गर्मियों में, रिलेशनल सॉफ्टवेयर, इंक. ने वैक्स कंप्यूटरों के लिए व्यावसायिक तौर पर उपलब्ध SQL के प्रथम कार्यान्वयन, ओरेकल V2 (संस्करण 2) को प्रस्तुत किया। "ओरेकल V2 [Oracle V2]" ने बाज़ार में IBM के सिस्टम/38 RDBMS के रिलीज़ को कुछ सप्ताहों में ही मात दे दी। 

सिस्टम की उपयोगिता और व्यवहारिकता का निर्धारण करने हेतु ग्राहक परीक्षण स्थलों पर SQL का परीक्षण करने के बाद IBM ने उनके सिस्टम आर (System R) के मूलरूप पर आधारित व्यावसायिक उत्पादों का विकास करना शुरु किया। सिस्टम आर (System R) के मूलरूप में सिस्टम/38 (System/38), एसक्यूएल/डीएस और डीबी २ शामिल थे और जो क्रमशः 1979, 1981 और 1983 में व्यावसायिक रूप से उपलब्ध थे।

SQL की आम आलोचनाओं में वेंडर्स के बीच विभिन्न प्रचालन तंत्रों पर सुवाह्यता की कमी, खोए हुए डेटा का अनुपयुक्त संचालन ("देखें ") और अनावश्यक रूप से जटिल और कभी-कभी अस्पष्ट भाषा व्याकरण और अर्थ शामिल थे। इसमें रिलेशनल ऐलजेब्रा जैसे औपचारिक भाषा की कठोरता का भी अभाव है।

SQL भाषा कई भाषा तत्वों में उप-विभाजित है, इनमें शामिल हैं:

SQL में सबसे आम कार्यवाही क्वेरी करना यानि आँकंणों के बारे में प्रश्न करना है, जो डिक्लेयरेटिव codice_1 स्टेटमेंट के साथ निष्पादित किया जाता है। codice_1 एक या एक से अधिक टेबल या एक्स्प्रेसंस से डेटा पुनःप्रतिष्ठापित करता है। मानक SELECT स्टेटमेंट्स का डेटाबेस पर कोई स्थायी प्रभाव नहीं होता है। codice_1 की कुछ गैर-मानक परिणतियों का स्थायी प्रभाव रह सकता है, जैसे codice_4 वाक्यविन्यास (सिन्टैक्स) जो कुछ डेटाबेसों में मौजूद रहता है।

क्वेरीज़, उपयोगकर्त्ता को वांछित डेटा की व्याख्या करने की क्षमता प्रदान करता है, इससे उस परिणाम (वांछित) को प्राप्त करने के लिए नियोजन, इष्टतमीकरण और आवश्यक भौतिक परिचालनों को अंजाम देने की ज़िम्मेदारी डेटाबेस मैनेजमेंट सिस्टम (DBMS) की होती है।

एक क्वेरी में codice_1 कीवर्ड के तुरंत बाद के परिणाम में सम्मिलित करने के लिए कॉलमों की एक सूची शामिल रहती है। यह निर्दिष्ट करने के लिए कि क्वेरी क्वेरिड टेबलों के सभी कॉलमों को रिटर्न करे, एक ऐस्टेरिस्क (codice_6) का भी उपयोग किया जा सकता है। codice_1, SQL का सबसे जटिल स्टेटमेंट है जिसमें वैकल्पिक कीवर्ड्स और क्लॉजेज़ भी होते हैं। इनमें शामिल हैं:

निम्नलिखित codice_1 क्वेरी का एक उदाहरण है जो महंगी किताबों की एक सूची को रिटर्न करता है। क्वेरी "BOOK" नामक टेबल से उन पंक्तियों को प्राप्त कर लेता है जिनमें कि "Price" कॉलम में मौजूद मान 100.00 से ज्यादा है। परिणाम "title" के अनुसार बढ़ते हुए क्रम में क्रमबद्ध रहता है। "select list" में मौजूद ऐस्टरिस्क (*) यह दर्शाता है कि "Book" टेबल के सारे कॉलम रिजल्ट सेट में उपस्थित रहने चाहिए। 
नीचे दिया गया उदाहरण किताबों की एक सूची और प्रत्येक किताब से संबद्ध लेखकों की संख्या रिटर्न कर मल्टिपल टेबल, ग्रुपिंग और ऐग्रीगेशन की एक क्वेरी को दर्शाता है।

उदाहरण आउटपुट निम्नलिखित के जैसा हो कता है:

इस पूर्व शर्त के अंतर्गत कि दोनों टेबलों में सिर्फ "isbn" ही सामान नाम वाले कॉलमों का नाम है और यह कि "title" नामक कॉलम सिर्फ "Books" टेबल में ही मौजूद है, ऊपर लिखित क्वेरी को निम्नलिखित रूप में दुबारा लिखा जा सकता है:

हालांकि, कई वेंडर्स या तो इस तरीके को सपोर्ट नहीं करते, या फिर उन्हें कॉलम नामकरण की परिपाटियों की ज़रुरत होती है।

SQL में संगृहीत मानों पर गणना करने के लिए ऑपरेटर्स और फंक्शन्स मौजूद होते हैं। SQL, डेटा को परियोजित करने के लिए "select list (सेलेक्ट सूची)" में एक्सप्रेशंस के प्रयोग की अनुमति देता है, जैसा निम्नलिखित उदाहरण में दर्शाया गया है जो उन पुस्तकों की एक सूची रिटर्न करता है जिनकी कीमत 100.00 से ज्यादा है, साथ में एक अतिरिक्त सेल्स टैक्स कॉलम भी है जिसमें "sales tax (सेल्स टैक्स)" का मान मौजूद है और यह मान "price (कीमत)" का 6% है।

SQL में नल (Null) की अवधारणा, रिलेशनल मॉडल में अनुपस्थित जानकारी को नियंत्रित करने के लिए डाली गई थी। ट्रू और फॉल्स के साथ नल (या अज्ञात) की स्थापना थ्री-वैल्यूड लॉजिक की नींव है। नल का कोई मान नहीं होता (और न ही यह किसी डेटा अनुक्षेत्र (डोमेन) का सदस्य है), अपितु यह अनुपस्थित जानकारी के लिए प्रयोग किया जाने वाला एक स्थानधारक या चिन्ह है। इसलिए नल (Null) के साथ की गयी तुलनाओं का परिणाम कभी भी ट्रू या फॉल्स नहीं हो सकता बल्कि यह सदा तीसरा लॉजिकल परिणाम- 'अननोन'(अज्ञात) होता है।

SQL, नल को अनुपस्थित जानकारी को नियंत्रित करने के लिए प्रयोग करता है। यह थ्री-वैल्यूड लॉजिक (3VL) को सपोर्ट करता है। वो नियम जो SQL थ्री-वैल्यूड लॉजिक को नियमित करते हैं, नीचे दिए गए हैं (p और q लॉजिकल अवस्थाओं को दर्शाते हैं). शब्द NULL SQL में एक आरक्षित कीवर्ड (रिज़र्व्ड कीवर्ड) भी है जो विशेष नल मार्कर (स्पेशल नल मार्कर) की पहचान करने में प्रयोग होता है।

इसके अतिरिक्त, चूंकि जब भी किसी चीज़ की तुलना नल से होती है तो SQL ऑपरेटर्स 'अननोन' रिटर्न करते हैं, इसलिए SQL विशेषतया नल संबंधी दो कम्पैरिजन प्रेडीकेट की सुविधा प्रदान करता है: codice_24 और codice_25 जांच करते हैं कि डेटा नल है या नहीं। 

ध्यान दें कि SQL केवल उन परिणामों के लिए मान रिटर्न करता है जिनके लिए WHERE क्लॉज़ एक ट्रू मान रिटर्न करता है। यानी, यह फॉल्स मान वाले परिणाम अपवर्जित कर देता है, लेकिन यह उनको भी अपवर्जित कर देता है जिनके मान मालूम नहीं (अज्ञात) हैं।

SQL, यूनिवर्सल क्वांटिफिकेशन (परिमाणन) को स्पष्टतया सपोर्ट नहीं करता और इसे 'निगेटेड एग्जिसटेनशिअल क्वानटिफिकेशन (परिमाणन)' के रूप में निकाला जाना ज़रूरी है।

'इन फिक्सड कम्पेरिज़न ऑपरेटर' "<row value expression> IS DISTINCT FROM <row value expression>" भी है जो दोनों ऑपरैंड के बराबर होने पर या NULL होने पर TRUE रिटर्न करता है। इसी प्रकार IS NOT DISTINCT FROM को "NOT (<row value expression> IS DISTINCT FROM <row value expression>") के रूप में परिभाषित किया जाता है।

डेटा मैनिप्युलेशन लैंग्वेज़ (DML), SQL का एक सबसेट है जिसे डेटा को जोड़ने (ऐड), अद्यतन करने (अपडेट) और विलोपन करने (डिलीट) के लिए प्रयोग किया जाता है।




ट्रांज़ैक्शंस, यदि उपलब्ध हैं, DML ऑपरेशंस को सम्मिलित कर लेते हैं:


एक बार जब codice_36 स्टेटमेंट पूरा हो जाता है, तो ट्रांज़ैक्शन में हुए बदलाव को वापस नहीं लाया जा सकता है।

codice_36 और codice_37 वर्तमान ट्रांज़ैक्शन का अंत कर देते हैं और डेटा लॉक्स को रिलीज़ कर देते हैं। एक codice_33 या इस जैसे स्टेटमेंट के अभाव में, SQL के सिमेंटिक्स कार्यान्वयन पर निर्भर होते हैं।
उदाहरण: "फंड ट्रांज़ैक्शन का एक क्लासिक बैंक हस्तांतरण (ट्रांसफर)" .

डेटा डेफिनिशन लैंग्वेज़ (DDL) टेबल और अनुक्रमणिका संरचना का प्रबंधन करता है। DDL की सबसे बुनियादी इकाइयां हैं- codice_44, codice_45, codice_46, codice_47 और codice_29 स्टेटमेंट्स:

उदाहरण:

SQL टेबल का प्रत्येक कॉलम, उस टाइप/टाइप्स को 'डिक्लेयर' करता है जो कॉलम में समाहित हो सकता है। ANSI SQL में निम्नलिखित डेटाटाइप्स शामिल हैं।




SQL, संख्याओं या तारीखों को 'राउंड' करने हेतु एक फंक्शन की सुविधा प्रदान करता है। इसे (DB2, PostgreSQL [पोस्टग्रीSQL], Oracle [ओरेकल] और MySQL में) codice_70, या (Sybase [सीबेस], Oracle [ओरेकल] और Microsoft SQL Server [माइक्रोसॉफ्ट SQL सर्वर]) में codice_71 कहा जाता है।


डेटा कंट्रोल लैंग्वेज़ (DCL) उपयोगकर्ताओं और उपयोगकर्ताओं के समूहों को डेटा को ऐक्सेस और मेनीप्यूलेट (जोड़-तोड़) करने के लिए अधिकृत करता है।
इसके दो मुख्य स्टेटमेंट्स हैं:


उदाहरण:

SQL एक विशिष्ट प्रयोजन: रिलेशनल डेटाबेस में रखे हुए डेटा के क्वेरी के लिए डिजाइन किया गया है। SQL एक सेट-आधारित, डिक्लेयरेटिव, क्वेरी लैंग्वेज़ है, न कि C या BASIC (बेसिक)की तरह का एक 'इम्पेरेटिव लेंग्वेज'. हालांकि, मानक SQL के विस्तारण मौजूद हैं जो प्रोसीडूरल प्रोगार्मिंग लैंग्वेज़ की क्रियात्मकता, जैसे कि 'कंट्रोल-ऑफ-फ्लो कन्सट्रक्ट्स', प्रदान करते हैं। ये हैं:

मानक SQL/PSM एक्सटेंशंस (विस्तारणों) और प्रोपरायटरी SQL एक्सटेंशंस (विस्तारणों) के अलावा, प्रोसीडूरल और ऑब्जेक्ट ओरिएन्टेड प्रोग्रामिंग विशिष्टताओं की सुविधा DBMS के दूसरे लैंग्वेज़ों के साथ एकीकरण के ज़रिये प्राप्त की जा सकती है। SQL मानक, SQL डेटाबेस में जावा कोड को सपोर्ट करने के लिए, SQL/JRT एक्सटेंशंस (जावा प्रोग्रामिंग लैंगवेज़ के लिए SQL रूटीन्स और टाइप्स) को निरूपित करता है। SQL सर्वर 2005 SQLCLR (SQL सर्वर कॉमन लैंग्वेज़ रन टाइम) का प्रयोग डेटाबेस में प्रबंधित .NET असेम्बलियों की मेजबानी के लिए होता है, जबकि SQL सर्वर के पूर्व संस्करण मुख्यतः C में लिखे गए अप्रबंधित एक्सटेन्डेड स्टोर्ड प्रोसीज़रों के उपयोग तक ही सीमित थे। अन्य डेटाबेस प्लैटफॉर्म्स, जैसे MySQL और पोस्टग्रीस (Postgres), फंक्शनों को पर्ल (Perl), पायथन (python), Tcl और C जैसे विभिन्न प्रकार के लैंग्वेज़ों में लिखने की अनुमति देते हैं।

SQL, रिलेशनल डेटाबेसों के साथ प्रयोग में लाए जाने हेतु एक डेक्लेयरेटिव कंप्यूटर लैंग्वेज़ है। सबसे दिलचस्प बात यह है कि SQL की मूल विशेषताओं में से कई विशेषताएं, रिलेशनल मॉडल के सिमेंटिक्स और इसके टपल कैलकुलस रियलाइज़ेशन से प्रेरित, लेकिन उल्लंघित, थे। SQL के हाल के विस्तारणों ने रिलेशनल संपूर्णता प्राप्त की लेकिन उल्लंघनों को और भी बदतर बना दिया है जिसके दस्तावेज़ "द थर्ड मेनिफेस्टो" में उपलब्ध हैं।

SQL के प्रयोगात्मक आलोचनाओं में शामिल हैं:

SQL के अधिकांश कार्यान्वयनों में सामान्यतः codice_72 या codice_73 डेटा प्रकारों जैसे स्टैंडर्ड SQL के बुनियादी विशेषताओं के समर्थन को भुला दिया जाता है। जिसके परिणामस्वरूप, शायद ही कभी SQL कोड को बिना संशोधनों के डेटाबेस सिस्टमों में रखा जा सकता है।

डेटाबेस सिस्टमों में पोर्टेबिलिटी (संगतता) के इस अभाव के पीछे कई कारण हैं:

SQL को 1986 में अमेरिकन नैशनल स्टैंडर्ड्स इंस्टिट्यूट [अमरीकी राष्ट्रीय मानक संस्थान] (ANSI) ने एक मानक के रूप में और 1987 में इंटरनैशनल ऑर्गनाइज़ेशन फॉर स्टैंडर्डाइज़ेशन [अंतर्राष्ट्रीय मनाकीकरण संगठन] (ISO) ने SQL-86 के रूप में ग्रहण किया। मूल SQL मानक ने घोषणा की कि SQL का आधिकारिक उच्चारण, "es queue el [एस क्यू एल]" है। कई अंग्रेज़ी-बोलने वाले डेटाबेस संव्यावसायिक अभी भी गैरमानक उच्चारण (शब्द "सिक्वल" की तरह) का प्रयोग करते हैं। SEQUEL, एक प्रारंभिक IBM डेटाबेस लैंग्वेज़, SQL लैंग्वेज़ का एक पूर्ववर्ती लैंग्वेज़ था।

1996 तक, नैशनल इंस्टिट्यूट ऑफ़ स्टैंडर्ड्स ऐंड टेक्नोलॉजी [राष्ट्रीय मानक और प्रौद्योगिकी संस्थान] (NIST) के डेटा प्रबंधन मानक कार्यक्रम के तहत SQL मानक के साथ SQL DBMS अनुपालन को प्रमाणिकता दी गई। विक्रेता अब अपने उत्पादों के अनुपालन को स्वयं ही प्रमाणिकता प्रदान करते हैं।

SQL मानक को कई बार संशोधित किया गया है जैसा कि नीचे दर्शाया गया है:
इच्छुक पार्टियां, इन SQL मानक दस्तावेजों को ISO या ANSI से खरीद सकती हैं। SQL:2008 का एक ड्राफ्ट, एक ज़िप आर्काइव के रूप में निःशुल्क उपलब्ध है।

SQL मानक को कई भागों में बांटा गया हैं जिनमें शामिल हैं:

SQL फ्रेमवर्क जो तार्किक अवधारणा प्रदान करता है

SQL/फाउंडेशन जिसे ISO/IEC 9075, भाग 2 में परिभाषित किया गया है। मानक के इस भाग में लैंग्वेज़ के सबसे मुख्य तत्व मौजूद हैं। इसमें अनिवार्य और वैकल्पिक दोनों ही विशेषताएं उपलब्ध हैं।

SQL/बाइंडिंग्स जो यह निर्दिष्ट करता है कि SQL, जावा (Java) को छोड़कर, अलग-अलग मेजबान लैंग्वेज़ों में कैसे बाध्य है।

SQL/CLI, या कॉल-लेवल इंटरफेस, इस भाग को ISO/IEC 9075, भाग 3 में परिभाषित किया गया है। SQL/CLI, सामान्य इंटरफेसिंग घटकों (संरचना और प्रक्रिया) को परिभाषित करता है जिसे अन्य प्रोग्रामिंग लैंग्वेज़ों में रचित अनुप्रयोगों से SQL स्टेटमेंट्स को निष्पादित करने के लिए प्रयोग किया जा सकता है। SQL/CLI को इस प्रकार से परिभाषित किया गया है कि SQL स्टेटमेंट्स और SQL/CLI प्रक्रिया कॉल्स को अनुप्रयोग के स्रोत कोड की कॉलिंग से अलग के रूप में व्यवहृत किया जाता है। ओपन डेटाबेस कनेक्टिविटी, SQL/CLI का एक जाना-माना सुपरसेट है। मानक के इस भाग में सिर्फ अनिवार्य विशेषताएं ही होती हैं।

SQL/PSM, या पर्ज़िस्टेंट स्टोर्ड मॉड्यूल्स [लगातार संग्रहित मॉड्यूल], इस भाग को ISO/IEC 9075, भाग 4 द्वारा परिभाषित किया गया है। SQL/PSM, नियंत्रण-प्रवाह, स्थिति प्रबंधन, स्टेटमेंट स्थिति संकेत और पुनर्संकेत, कर्सर और स्थानीय वेरिएबल और वेरिएबल और पैरामीटर के लिए अभिव्यक्ति का कार्य सहित SQL के प्रक्रियात्मक विस्तारणों को मानकीकृत करता है। इसके अतिरिक्त, SQL/PSM, पर्ज़िस्टेंट डेटाबेस लैंग्वेज़ के नित्यकर्मों की घोषणा और रखरखाव का कार्य करता है। मानक के इस भाग में केवल वैकल्पिक विशेषताएं होती हैं।

SQL/MED, या मैनेजमेंट ऑफ़ एक्सटर्नल डेटा [बाह्य डेटा का प्रबंधन], इस भाग को ISO/IEC 9075, भाग 9 द्वारा परिभाषित किया गया है। SQL/MED, SQL में विस्तारण प्रदान करता है जो एक्सटर्नल डेटा का प्रबंधन करने के लिए SQL को अनुमति देने के लिए फोरेन-डेटा रैपर्स और डेटालिंक प्रकारों को परिभाषित करता है। एक्सटर्नल डेटा, वह डेटा है जिसे SQL-आधारित DBMS में ऐक्सेस तो किया जा सकता है लेकिन इसका प्रबंधन नहीं किया जा सकता है। मानक के इस भाग में केवल वैकल्पिक विशेषताएं होती हैं।

SQL/OLB, या ऑब्जेक्ट लैंग्वेज़ बाइंडिंग्स, इस भाग को ISO/IEC 9075, भाग 10 द्वारा परिभाषित किया गया है। SQL/OLB, SQLJ के वाक्यविन्यास और सिमेंटिक्स को परिभाषित करता है जो जावा (Java) में SQL एम्बेडेड होता है। यह मानक, SQLJ अनुप्रयोगों की बाइनरी पोर्टेबिलिटी सुनिश्चित करने वाले क्रियाविधियों का भी वर्णन करता है और विभिन्न जावा (Java) पैकेजों और उनमें समाहित वर्गों को भी निर्दिष्ट करता है। मानक के इस भाग में केवल वैकल्पिक विशेषताएं होती हैं।

SQL/MM (मल्टीमीडिया), बड़े, जटिल और कभी-कभी स्ट्रीमिंग आइटम वाले डेटा जैसे वीडियो, ऑडियो और स्थानिक डेटा के साथ होशियारी से निपटने के लिए SQL का विस्तार करता है।

SQL/स्कीमाटा, या इनफॉरमेशन ऐंड डेफिनिशन स्कीमाज़, इस भाग को ISO/IEC 9075, भाग 11 द्वारा परिभाषित किया गया है। SQL/स्कीमाटा, इनफॉरमेशन स्कीमा और डेफिनिशन स्कीमा को परिभाषित करता है और इसके लिए यह SQL डेटाबेसों और ऑब्जेक्टों स्व-वर्णी बनाने के लिए उपकरणों का एक सामान्य सेट प्रदान करता है। इन उपकरणों में SQL ऑब्जेक्ट परिचायक, संरचना और एकीकरण बाध्यता, सुरक्षा और प्राधिकरण निर्दिष्टीकरण, ISO/IEC 9075 की विशेषता और पॅकेज, SQL-आधारित DBMS कार्यान्वयनों द्वारा प्रदत्त विशेषताओं का समर्थन, SQL-आधारित DBMS कार्यान्वयन सूचना और साइज़िंग आइटम और DBMS कार्यान्वयनों द्वारा समर्थित मूल्य शामिल हैं।<ref name="ISO/IEC 9075-11:2008"></ref> मानक के इस भाग में अनिवार्य और वैकल्पिक दोनों विशेषताएं शामिल हैं।

SQL/JRT, या SQL रूटीन्स ऐंड टाइप्स फॉर द जावा प्रोग्रामिंग लैंग्वेज़ (जावा प्रोग्रामिंग लैंग्वेज़ के लिए SQL के नित्यकर्म और प्रकार), इस भाग को ISO/IEC 9075, भाग 13 द्वारा परिभाषित किया गया है। SQL/JRT, स्थिर जावा तरीकों को SQL अनुप्रयोग के भीतर से नित्यकर्मों के रूप में लागू करने की क्षमता को निर्दिष्ट करता है। यह जावा वर्गों को SQL संरचित प्रयोक्ता-परिभाषित प्रकारों के रूप में प्रयुक्त करने की क्षमता के लिए भी कॉल करता है। मानक के इस भाग में केवल वैकल्पिक विशेषताएं ही मिलती हैं।

SQL/XML, या XML-संबंधित निर्दिष्टीकरण, इस भाग को ISO/IEC 9075, भाग 14 द्वारा परिभाषित किया गया है। SQL/XML, SQL के साथ संयोजन के रूप में XML का उपयोग करने के लिए SQL-आधारित विस्तारणों को निर्दिष्ट करता है। XML डेटा प्रकार के साथ-साथ SQL डेटाबेस में XML के फेर बदल और भंडारण का समर्थन करने के लिए XML से SQL डेटा प्रकार मैपिंग, कई रूटीन्स और फंक्शंस का भी आरंभ किया गया है। मानक के इस भाग में केवल वैकल्पिक विशेषताएं ही शामिल है।

रिलेशनल क्वेरी लैंग्वेज़ और SQL के विकल्पों में एक अन्तर स्थापित करना आवश्यक है। SQL के प्रस्तावित रिलेशनल विकल्पों को नीचे प्रस्तुत किया गया है। रिलेशनल के विकल्पों के लिए नेविगेशनल डेटाबेस देखें:


रिसर्च के संदर्भ में भी संक्षेप में विचार-विमर्श किया।
